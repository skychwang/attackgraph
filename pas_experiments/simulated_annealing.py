'''
Runs simulated annealing for parameters in [0, 1]^d, using a random distribution with mean
equal to the current parameter and a given variance to sample neighbors, linear
annealing of the temperature parameter, and the exponential distribution to decide whether
to switch to a new point that is worse than the old one.
Note that the neighbor distribution is nudged away from 0 or 1 toward 0.1 or 0.9 before
sampling randomly.
'''
import random
import time
from math import exp, sqrt
from numpy.random import beta, normal

def get_temp(time_step, max_steps, max_temp):
    '''
    Temperature is linearly annealed fro max_temp at time_step 0, to 0 at time_step
    max_steps.
    '''
    if time_step < 0 or time_step > max_steps:
        raise ValueError("time_step must be in [0, " + str(max_steps) + "]: " + \
            str(time_step))
    if max_temp <= 0.0:
        raise ValueError("max_temp must be > 0: " + str(max_temp))
    time_left_frac = (max_steps - time_step) * 1. / max_steps
    return time_left_frac * max_temp

def normed(param):
    '''
    Try to prevent the distribution of neighbors from being squashed against 0 or 1,
    by pushing the parameters toward 0.1 or 0.9 when finding neighbor parameters.
    '''
    if param < 0.1:
        return (param + 0.1) / 2
    if param > 0.9:
        return (param + 0.9) / 2
    return param

def get_beta_params(mean, variance):
    '''
    Find the parameters of a Beta distribution with the given mean and variance.
    '''
    # https://stats.stackexchange.com/questions/12232/
    #     calculating-the-parameters-of-a-beta-distribution-using-the-mean-and-variance
    if mean <= 0.0 or mean >= 1.0:
        raise ValueError("Mean should be in (0, 1): " + str(mean))
    if variance <= 0.0 or variance >= 1.0:
        raise ValueError("Variance should be in (0, 1): " + str(variance))
    a_param = (((1. - mean) / variance) - (1. / mean)) * variance
    b_param = a_param * ((1. / mean) - 1)
    if a_param <= 0. or b_param <= 0.:
        raise ValueError("Beta should be a_param and b_param > 0: " + str(a_param) + \
            ", " + str(b_param) + ". Problem with mean: " + str(mean) + ", variance: " + \
            str(variance))
    return (a_param, b_param)

def neighbor_truncated_gaussian(param, neighbor_variance):
    if param < 0.0 or param > 1.0:
        raise ValueError("param must be in [0, 1]: " + str(param))
    if neighbor_variance <= 0.0 or neighbor_variance >= 1.0:
        raise ValueError("neighbor_variance must be in (0, 1): " + str(neighbor_variance))
    normed_param = normed(param)
    result = normal(normed_param, sqrt(neighbor_variance))
    while result <= 0.0 or result >= 1.0:
        result = normal(normed_param, sqrt(neighbor_variance))
    return result

def neighbor_beta(param, neighbor_variance):
    '''
    Given param in [0, 1], normalize it by pushing away from 0 or 1 toward 0.1 or 0.9
    if needed, then sample a Beta distribution with mean param and variance
    neighbor_variance, returning the result.
    '''
    if param < 0.0 or param > 1.0:
        raise ValueError("param must be in [0, 1]: " + str(param))
    if neighbor_variance <= 0.0 or neighbor_variance >= 1.0:
        raise ValueError("neighbor_variance must be in (0, 1): " + str(neighbor_variance))
    normed_param = normed(param)
    a_param, b_param = get_beta_params(normed_param, neighbor_variance)
    return beta(a_param, b_param)[0]

def should_switch_params(old_value, new_value, cur_temp):
    '''
    Always return True if new_value > old_value or old_value is None.
    Otherwise, return True with probability:
        exp((new_value - old_value) / cur_temp).
    '''
    if old_value is None or new_value > old_value:
        return True
    cur_prob = exp((new_value - old_value) / cur_temp)
    return random.random() < cur_prob

# works with parameter vector scaled to [0, 1] in each dimension.
def find_params_simulated_annealing(param_count, max_steps, max_temp, samples_per_param,
                                    neighbor_variance, sample_function, should_print,
                                    initial_params, att_mixed_strat):
    '''
    Run simulated annealing in space [0, 1]^param_count, for max_steps trials.
    Temperature will be annealed from max_temp to 0.
    The value of the current parameter vectcor will be generated by calling
    sample_function(cur_neighbor, samples_per_param), which should give the mean result
    of samples_per_param trials with parameter vector cur_neighbor.
    The neighbor of vector saved_params is generated independently for each dimension,
    using a Beta distribution with mean at the current value, and variance
    neighbor_variance.
    If should_print is True, will print out each time the saved_params is altered.
    Returns the final saved parameters and their estimated mean value.
    The opponent (attacker) plays the mixed strategy att_mixed_strat.
    '''
    if param_count < 1:
        raise ValueError("param_count must be >= 1: " + str(param_count))
    if max_steps < 1:
        raise ValueError("max_steps must be >= 1: " + str(max_steps))
    if max_temp <= 0.0:
        raise ValueError("max_temp must be > 0: " + str(max_temp))
    if samples_per_param < 1:
        raise ValueError("samples_per_param must be >= 1: " + str(samples_per_param))
    if neighbor_variance <= 0.0 or neighbor_variance >= 1.0:
        raise ValueError("neighbor_variance must be in (0, 1): " + str(neighbor_variance))
    if initial_params is not None:
        if len(initial_params) != param_count:
            raise ValueError("initial_params has wrong length: " + str(len(initial_params)))
        if min(initial_params) <= 0.0 or max(initial_params) >= 1.0:
            raise ValueError("initial_params has invalid value: " + str(initial_params))

    start_time = time.time()
    if initial_params is None:
        saved_params = [random.random() for _ in range(param_count)]
    else:
        saved_params = initial_params.copy()
    saved_value = None
    best_params = saved_params.copy()
    best_value = None
    fmt = "{0:.2f}"
    for time_step in range(max_steps):
        cur_temp = get_temp(time_step, max_steps, max_temp)
        cur_neighbor = [neighbor_truncated_gaussian(x, \
            neighbor_variance) for x in saved_params]
        cur_mean_result = sample_function(cur_neighbor, samples_per_param, att_mixed_strat)
        if best_value is None or cur_mean_result > best_value:
            best_params = cur_neighbor.copy()
            best_value = cur_mean_result
        if should_switch_params(saved_value, cur_mean_result, cur_temp):
            saved_params = cur_neighbor.copy()
            saved_value = cur_mean_result
            if should_print:
                print("Updated params at anneal step " + str(time_step) + ": " + \
                    str([fmt.format(x) for x in saved_params]) + ", value: " + \
                    fmt.format(saved_value))
    duration = time.time() - start_time
    print("Best params: " + str([fmt.format(x) for x in best_params]))
    print("Best mean value: " + fmt.format(best_value))
    print("Seconds used: " + fmt.format(duration))
    return best_params, best_value
